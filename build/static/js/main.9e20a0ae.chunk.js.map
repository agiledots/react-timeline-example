{"version":3,"sources":["generate-fake-data.js","CustomTimeline.jsx","App.js","serviceWorker.js","index.js"],"names":["schedules","schedule_name","playlist_name","available_date_from","available_date_to","available_time_from","available_time_to","connectReducer","accumulator","currentValue","target","Array","isArray","push","lastItem","pop","group","color","end","isSame","start","newItem","Object","objectSpread","splitTimereducer","result","forEach","item","isAfter","isBefore","isSameOrAfter","isSameOrBefore","generate_fake_data","groups","i","length","id","concat","title","rightTitle","rightTitleKey","tip","bgColor","console","log","scheduleTimes","show_start_date","arguments","undefined","show_end_date","map","schedule","times","startDate","moment","format","day","startTime","endTime","add","detailTimes","splitData","index","time","flat","reduce","splitTime","data","items","itemProps","data-tip","keys","groupIdKey","groupTitleKey","groupRightTitleKey","itemIdKey","itemTitleKey","itemDivTitleKey","itemGroupKey","itemTimeStartKey","itemTimeEndKey","groupLabelKey","dateFormat","App","props","_this","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","itemRenderer","_ref","itemContext","timelineContext","getItemProps","_getResizeProps","getResizeProps","leftResizeProps","left","rightResizeProps","right","backgroundColor","selected","dragging","selectedBgColor","borderColor","resizing","react_default","a","createElement","style","borderStyle","borderWidth","borderRadius","borderLeftWidth","borderRightWidth","onMouseDown","useResizeHandle","height","dimensions","overflow","paddingLeft","textOverflow","whiteSpace","handleItemMove","itemId","dragTime","newGroupOrder","_this$state","state","setState","assign","handleItemResize","edge","onBoundsChange","canvasTimeStart","canvasTimeEnd","onTimeChange","visibleTimeStart","visibleTimeEnd","updateScrollCanvas","_generateFakeData","generateFakeData","defaultTimeStart","startOf","toDate","defaultTimeEnd","_this$state2","lib_default","sidebarContent","itemsSorted","itemTouchSendsClick","stackItems","itemHeightRatio","showCursorLine","canMove","canResize","onItemMove","onItemResize","Component","CustomTimeline_App","render","App_App","document","getElementById","Boolean","window","location","hostname","match","ReactDOM","src_App","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"qRAEMA,EAAY,CAChB,CACEC,cAAe,oBACfC,cAAe,oBACfC,oBAAqB,aACrBC,kBAAmB,aACnBC,oBAAqB,WACrBC,kBAAmB,YAErB,CACEL,cAAe,oBACfC,cAAe,oBACfC,oBAAqB,aACrBC,kBAAmB,aACnBC,oBAAqB,GACrBC,kBAAmB,IAErB,CACEL,cAAe,oBACfC,cAAe,oBACfC,oBAAqB,aACrBC,kBAAmB,aACnBC,oBAAqB,WACrBC,kBAAmB,YAErB,CACEL,cAAe,oBACfC,cAAe,oBACfC,oBAAqB,aACrBC,kBAAmB,aACnBC,oBAAqB,GACrBC,kBAAmB,IAErB,CACEL,cAAe,oBACfC,cAAe,oBACfC,oBAAqB,aACrBC,kBAAmB,GACnBC,oBAAqB,WACrBC,kBAAmB,YAErB,CACEL,cAAe,oBACfC,cAAe,oBACfC,oBAAqB,aACrBC,kBAAmB,aACnBC,oBAAqB,WACrBC,kBAAmB,aAUjBC,EAAiB,SAACC,EAAaC,GACnC,IAAIC,EAAS,GACRC,MAAMC,QAAQJ,GAGjBE,EAASF,EAFTE,EAAOG,KAAKL,GAKd,IAAIM,EAAWJ,EAAOK,MAEtB,GAAID,EAASE,OAASP,EAAaO,OAC9BF,EAASG,OAASR,EAAaQ,OAA2B,SAAlBH,EAASG,OACjDH,EAASI,IAAIC,OAAOV,EAAaW,OAAQ,CAC5C,IAAMC,EAAOC,OAAAC,EAAA,EAAAD,CAAA,GAAQR,EAAR,CAAkBM,MAAON,EAASM,MAAOF,IAAKT,EAAaS,MACxER,EAAOG,KAAKQ,QAEZX,EAAOG,KAAKC,GACZJ,EAAOG,KAAKJ,GAGd,OAAOC,GASHc,EAAmB,SAAChB,EAAaC,GAErC,IAAIC,EAAS,GACRC,MAAMC,QAAQJ,GAGjBE,EAASF,EAFTE,EAAOG,KAAKL,GAMd,IAAIiB,EAAS,GA4Eb,OA1EAf,EAAOgB,QAAQ,SAAAC,GAIK,QAAdA,EAAKV,OAAmBU,EAAKX,OAASP,EAAaO,OAIjDP,EAAaW,MAAMQ,QAAQD,EAAKP,QAAUX,EAAaW,MAAMS,SAASF,EAAKT,MAC1ET,EAAaS,IAAIU,QAAQD,EAAKT,OAEjCO,EAAOZ,KAAPS,OAAAC,EAAA,EAAAD,CAAA,GAAiBK,EAAjB,CAAuBT,IAAKT,EAAaW,MAAOH,MAAO,UACvDQ,EAAOZ,KAAPS,OAAAC,EAAA,EAAAD,CAAA,GAAiBK,EAAjB,CAAuBP,MAAOX,EAAaW,MAAOH,MAAO,YAKvDR,EAAaW,MAAMQ,QAAQD,EAAKP,QAAUX,EAAaS,IAAIW,SAASF,EAAKT,MACxET,EAAaS,IAAIW,SAASF,EAAKT,OAElCO,EAAOZ,KAAPS,OAAAC,EAAA,EAAAD,CAAA,GAAiBK,EAAjB,CAAuBT,IAAKT,EAAaW,MAAOH,MAAO,UACvDQ,EAAOZ,KAAPS,OAAAC,EAAA,EAAAD,CAAA,GAAiBK,EAAjB,CAAuBP,MAAOX,EAAaW,MAAOF,IAAKT,EAAaS,IAAKD,MAAO,WAChFQ,EAAOZ,KAAPS,OAAAC,EAAA,EAAAD,CAAA,GAAiBK,EAAjB,CAAuBP,MAAOX,EAAaS,IAAKD,MAAO,WAOrDR,EAAaW,MAAMS,SAASF,EAAKP,QAAUX,EAAaS,IAAIU,QAAQD,EAAKT,MAC3EO,EAAOZ,KAAPS,OAAAC,EAAA,EAAAD,CAAA,GAAiBK,EAAjB,CAAuBV,MAAO,WAQ5BR,EAAaS,IAAIU,QAAQD,EAAKP,QAAUX,EAAaS,IAAIW,SAASF,EAAKT,MACtET,EAAaW,MAAMS,SAASF,EAAKP,SAEpCK,EAAOZ,KAAPS,OAAAC,EAAA,EAAAD,CAAA,GAAiBK,EAAjB,CAAuBT,IAAKT,EAAaS,IAAKD,MAAO,WACrDQ,EAAOZ,KAAPS,OAAAC,EAAA,EAAAD,CAAA,GAAiBK,EAAjB,CAAuBP,MAAOX,EAAaS,IAAKD,MAAO,WAOrDR,EAAaW,MAAMU,cAAcH,EAAKT,MACxCO,EAAOZ,KAAKc,GAKVlB,EAAaS,IAAIa,eAAeJ,EAAKP,QACvCK,EAAOZ,KAAKc,GAMVlB,EAAaW,MAAMD,OAAOQ,EAAKP,QAAUX,EAAaS,IAAIC,OAAOQ,EAAKT,MACxEO,EAAOZ,KAAPS,OAAAC,EAAA,EAAAD,CAAA,GAAiBK,EAAjB,CAAuBV,MAAO,YAKhCQ,EAAOZ,KAAKc,KAIhBF,EAAOZ,KAAKJ,GAELgB,GAiGMO,EAAA,WAEb,IADA,IAAIC,EAAS,GACJC,EAAI,EAAGA,EAAIlC,EAAUmC,OAAQD,IACpCD,EAAOpB,KAAK,CACVuB,GAAE,GAAAC,OAAKH,GACPI,MAAOtC,EAAUkC,GAAGhC,cACpBqC,WAAYvC,EAAUkC,GAAGjC,cACzBuC,cAAe,aACfC,IAAK,yBACLC,QAAS,SAMbC,QAAQC,IAAI,sEACZ,IAAMC,EAjFY,SAAC7C,GAA4E,IAAjE8C,EAAiEC,UAAAZ,OAAA,QAAAa,IAAAD,UAAA,GAAAA,UAAA,GAA/C,aAAcE,EAAiCF,UAAAZ,OAAA,QAAAa,IAAAD,UAAA,GAAAA,UAAA,GAAjB,aAE9E,OAAO/C,EAAUkD,IAAI,SAACC,GAAa,IAE3BhD,EAAmFgD,EAAnFhD,oBAAqBC,EAA8D+C,EAA9D/C,kBAAmBC,EAA2C8C,EAA3C9C,oBAAqBC,EAAsB6C,EAAtB7C,kBAUnE,GAJAH,EAAsBA,EAAsB2C,EAAkBA,EAAkB3C,EAChFC,GAJAA,EAAoBA,GAAqB,cAID6C,EAAgB7C,EAAoB6C,EAGtE5C,GAAuBC,EAWtB,CASL,IANA,IAAI8C,EAAQ,GAGRC,EAAYC,IAAOnD,GAGhBkD,EAAUtB,eAAeuB,IAAOlD,KAAqB,CAE1DuC,QAAQC,IAAI,6BAA+BU,IAAOlD,GAAmBmD,UAErE,IAAMC,EAAMH,EAAUE,OAAO,cAGvBE,EAAYH,IAAM,GAAAjB,OAAImB,EAAJ,KAAAnB,OAAWhC,IAE7BqD,EAAUJ,IAAM,GAAAjB,OAAImB,EAAJ,KAAAnB,OAAW/B,IAGjC8C,EAAMvC,KAAK,CAAC4C,EAAWC,IAGvBL,EAAYA,EAAUM,IAAI,EAAG,OAG/B,OAAOP,EApCP,IAAMK,EAAYH,IAAOnD,GACnBuD,EAAUJ,IAAOlD,GAAmBuD,IAAI,EAAG,OAG7CP,EAAQ,GAGZ,OAFAA,EAAMvC,KAAK,CAAC4C,EAAWC,IAEhBN,IA0DWQ,CAAY5D,EAAW,aAAc,cAC3D2C,QAAQC,IAAIC,GAIZF,QAAQC,IAAI,8CACZ,IAAMiB,EA/GU,SAAChB,GAejB,OAbkBA,EAAcK,IAAI,SAACE,EAAOU,GAC1C,OAAOV,EAAMF,IAAI,SAAAa,GACf,MAAO,CACL/C,MAAO8C,EACP1C,MAAO2C,EAAK,GACZ7C,IAAK6C,EAAK,GACV9C,MAAO,YAKiB+C,OAEbC,OAAOzC,GAgGN0C,CAAUrB,GAC5BF,QAAQC,IAAIiB,GAIZ,IAAMM,EAAON,EAAUI,OAAO1D,GAC9BoC,QAAQC,IAAIuB,GAIZ,IAAIC,EAAQ,GAoBZ,OAnBAD,EAAKzC,QAAQ,SAACqC,EAAM7B,GAElB,IAAMI,EAAK,GAAAD,OAAM0B,EAAK3C,MAAMmC,SAAjB,MAAAlB,OAA8B0B,EAAK7C,IAAIqC,UAElDa,EAAMvD,KAAK,CACTuB,GAAE,GAAAC,OAAKH,GACPlB,MAAO+C,EAAK/C,MACZsB,MAAOA,EACPlB,MAAO2C,EAAK3C,MACZF,IAAK6C,EAAK7C,IACVmD,UAAW,CAAEC,WAAYhC,GACzBI,QAAuB,QAAdqB,EAAK9C,MAAkB,UAAY,WAKhD0B,QAAQC,IAAIwB,GAGL,CAAEnC,SAAQmC,UC5TfG,EAAO,CACTC,WAAY,KACZC,cAAe,QACfC,mBAAoB,aACpBC,UAAW,KACXC,aAAc,QACdC,gBAAiB,QACjBC,aAAc,QACdC,iBAAkB,QAClBC,eAAgB,MAChBC,cAAe,SAGXC,EAAa,sBAGEC,cACnB,SAAAA,EAAYC,GAAO,IAAAC,EAAA/D,OAAAgE,EAAA,EAAAhE,CAAAiE,KAAAJ,IACjBE,EAAA/D,OAAAkE,EAAA,EAAAlE,CAAAiE,KAAAjE,OAAAmE,EAAA,EAAAnE,CAAA6D,GAAAO,KAAAH,KAAMH,KAuBRO,aAAe,SAAAC,GAMT,IALJjE,EAKIiE,EALJjE,KAEAkE,GAGID,EAJJE,gBAIIF,EAHJC,aACAE,EAEIH,EAFJG,aAEIC,GACuDC,EADvDL,EADJK,kBAEcC,EADVF,EACIG,KAA8BC,EADlCJ,EAC2BK,MACzBC,EAAkBT,EAAYU,SAChCV,EAAYW,SACV,MACA7E,EAAK8E,gBACP9E,EAAKe,QACHgE,EAAcb,EAAYc,SAAW,MAAQhF,EAAKV,MACxD,OACE2F,EAAAC,EAAAC,cAAA,MACMf,EAAa,CACfgB,MAAO,CACLT,kBACArF,MAAOU,EAAKV,MACZyF,cACAM,YAAa,QACbC,YAAa,EACbC,aAAc,EACdC,gBAAiBtB,EAAYU,SAAW,EAAI,EAC5Ca,iBAAkBvB,EAAYU,SAAW,EAAI,GAE/Cc,YAAa,WACX1E,QAAQC,IAAI,gBAAiBjB,GAC7BgB,QAAQC,IAAI,eAAgBU,IAAO3B,EAAKP,OAAOmC,OAAO2B,IACtDvC,QAAQC,IAAI,eAAgBU,IAAO3B,EAAKT,KAAKqC,OAAO2B,OAIvDW,EAAYyB,gBAAkBV,EAAAC,EAAAC,cAAA,MAASZ,GAAsB,KAE9DU,EAAAC,EAAAC,cAAA,OACEC,MAAO,CACLQ,OAAQ1B,EAAY2B,WAAWD,OAC/BE,SAAU,SACVC,YAAa,EACbC,aAAc,WACdC,WAAY,WAGb/B,EAAYvD,OAGduD,EAAYyB,gBAAkBV,EAAAC,EAAAC,cAAA,MAASV,GAAuB,OAxElDf,EA6EnBwC,eAAiB,SAACC,EAAQC,EAAUC,GAAkB,IAAAC,EAC1B5C,EAAK6C,MAAvB9D,EAD4C6D,EAC5C7D,MAEFpD,EAH8CiH,EACrChG,OAEM+F,GAErB3C,EAAK8C,SAAS,CACZ/D,MAAOA,EAAMlB,IAAI,SAAAvB,GAAI,OACnBA,EAAKS,KAAO0F,EACRxG,OAAO8G,OAAO,GAAIzG,EAAM,CACtBP,MAAO2G,EACP7G,IAAK6G,GAAYpG,EAAKT,IAAMS,EAAKP,OACjCJ,MAAOA,EAAMoB,KAEfT,MAIRgB,QAAQC,IAAI,QAASkF,EAAQC,EAAUC,IA9FtB3C,EAiGnBgD,iBAAmB,SAACP,EAAQ/D,EAAMuE,GAAS,IACjClE,EAAUiB,EAAK6C,MAAf9D,MAERiB,EAAK8C,SAAS,CACZ/D,MAAOA,EAAMlB,IAAI,SAAAvB,GAAI,OACnBA,EAAKS,KAAO0F,EACRxG,OAAO8G,OAAO,GAAIzG,EAAM,CACtBP,MAAgB,SAATkH,EAAkBvE,EAAOpC,EAAKP,MACrCF,IAAc,SAAToH,EAAkB3G,EAAKT,IAAM6C,IAEpCpC,MAIRgB,QAAQC,IAAI,UAAWkF,EAAQ/D,EAAMuE,IA/GpBjD,EAkHnBkD,eAAiB,SAACC,EAAiBC,GACjC9F,QAAQC,IAAI,2BAEZD,QAAQC,IAAI,mBAAqBU,IAAOkF,GAAiBjF,UACzDZ,QAAQC,IAAI,iBAAmBU,IAAOmF,GAAelF,WAtHpC8B,EA0HnBqD,aAAe,SAACC,EAAkBC,EAAgBC,GAChDlG,QAAQC,IAAI,yBAEZD,QAAQC,IAAI,oBAAsBU,IAAOqF,GAAkBpF,UAC3DZ,QAAQC,IAAI,kBAAoBU,IAAOsF,GAAgBrF,WA9HtC,IAAAuF,EAGSC,IAAlB9G,EAHS6G,EAGT7G,OAAQmC,EAHC0E,EAGD1E,MACV4E,EAAmB1F,MACtB2F,QAAQ,OACRtF,IAAI,GAAI,OACRuF,SACGC,EAAiB7F,MACpB2F,QAAQ,OACRtF,IAAI,GAAI,OACRuF,SAXc,OAajB7D,EAAK6C,MAAQ,CACXjG,SACAmC,QACA4E,mBACAG,kBAGFxG,QAAQC,IAAI,qBAAuBoG,GACnCrG,QAAQC,IAAI,mBAAqBuG,GArBhB9D,wEAmIV,IAAA+D,EACqD7D,KAAK2C,MAAzDjG,EADDmH,EACCnH,OAAQmC,EADTgF,EACShF,MAAO4E,EADhBI,EACgBJ,iBAAkBG,EADlCC,EACkCD,eAEzC,OACEvC,EAAAC,EAAAC,cAACuC,EAAAxC,EAAD,CACE5E,OAAQA,EACRmC,MAAOA,EACPG,KAAMA,EACN+E,eAAgB1C,EAAAC,EAAAC,cAAA,6BAChByC,aAAW,EACXC,qBAAqB,EACrBC,YAAU,EACVC,gBAAiB,IACjBC,gBAAc,EACdC,SAAS,EACTC,WAAW,EACXb,iBAAkBA,EAClBG,eAAgBA,EAChBxD,aAAcJ,KAAKI,aACnBmE,WAAYvE,KAAKsC,eACjBkC,aAAcxE,KAAK8C,iBACnBE,eAAgBhD,KAAKgD,wBAzJIyB,aClB3B7E,SAAM,kBACVyB,EAAAC,EAAAC,cAAA,WACEF,EAAAC,EAAAC,cAACmD,EAAD,SAIJC,iBAAOtD,EAAAC,EAAAC,cAACqD,EAAD,MAASC,SAASC,eAAe,SAEzBlF,QCDKmF,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAAST,OAAOtD,EAAAC,EAAAC,cAAC8D,EAAD,MAASR,SAASC,eAAe,SD2H3C,kBAAmBQ,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.9e20a0ae.chunk.js","sourcesContent":["import moment from \"moment\";\r\n\r\nconst schedules = [\r\n  {\r\n    schedule_name: 'schedule_name_001',\r\n    playlist_name: 'playlist_name_001',\r\n    available_date_from: '2019-04-01',\r\n    available_date_to: '2019-04-03',\r\n    available_time_from: '08:00:00',\r\n    available_time_to: '20:00:00',\r\n  },\r\n  {\r\n    schedule_name: 'schedule_name_002',\r\n    playlist_name: 'playlist_name_002',\r\n    available_date_from: '2019-04-02',\r\n    available_date_to: '2019-04-19',\r\n    available_time_from: '',\r\n    available_time_to: '',\r\n  },\r\n  {\r\n    schedule_name: 'schedule_name_003',\r\n    playlist_name: 'playlist_name_003',\r\n    available_date_from: '2019-02-28',\r\n    available_date_to: '2019-04-07',\r\n    available_time_from: '19:00:00',\r\n    available_time_to: '22:00:00',\r\n  },\r\n  {\r\n    schedule_name: 'schedule_name_004',\r\n    playlist_name: 'playlist_name_004',\r\n    available_date_from: '2019-04-06',\r\n    available_date_to: '2019-04-10',\r\n    available_time_from: '',\r\n    available_time_to: '',\r\n  },\r\n  {\r\n    schedule_name: 'schedule_name_005',\r\n    playlist_name: 'playlist_name_005',\r\n    available_date_from: '2019-04-06',\r\n    available_date_to: '',\r\n    available_time_from: '14:00:00',\r\n    available_time_to: '16:00:00',\r\n  },\r\n  {\r\n    schedule_name: 'schedule_name_006',\r\n    playlist_name: 'playlist_name_006',\r\n    available_date_from: '2019-04-16',\r\n    available_date_to: '2019-04-26',\r\n    available_time_from: '14:00:00',\r\n    available_time_to: '16:00:00',\r\n  },\r\n]\r\n\r\n\r\n/**\r\n * 连接被分割的白色区域\r\n * @param {已经计算出来的结果} accumulator \r\n * @param {需要计算的项目} currentValue \r\n */\r\nconst connectReducer = (accumulator, currentValue) => {\r\n  let target = []\r\n  if (!Array.isArray(accumulator)) {\r\n    target.push(accumulator)\r\n  } else {\r\n    target = accumulator\r\n  }\r\n\r\n  let lastItem = target.pop()\r\n\r\n  if (lastItem.group == currentValue.group\r\n    && lastItem.color == currentValue.color && lastItem.color == \"white\"\r\n    && lastItem.end.isSame(currentValue.start)) {\r\n    const newItem = { ...lastItem, start: lastItem.start, end: currentValue.end }\r\n    target.push(newItem)\r\n  } else {\r\n    target.push(lastItem)\r\n    target.push(currentValue)\r\n  }\r\n\r\n  return target\r\n}\r\n\r\n\r\n/**\r\n * 将重复的时间分割，并且表示白色和蓝色区域\r\n * @param {已经处理好的结果} accumulator \r\n * @param {下一个待处理的项目} currentValue \r\n */\r\nconst splitTimereducer = (accumulator, currentValue) => {\r\n\r\n  let target = []\r\n  if (!Array.isArray(accumulator)) {\r\n    target.push(accumulator)\r\n  } else {\r\n    target = accumulator\r\n  }\r\n\r\n  // \r\n  let result = []\r\n\r\n  target.forEach(item => {\r\n    // currentValue.start\r\n    // currentValue.end\r\n\r\n    if (item.color == 'blue' && item.group != currentValue.group) {\r\n\r\n      // item          --------\r\n      // currentValue       -----------\r\n      if (currentValue.start.isAfter(item.start) && currentValue.start.isBefore(item.end)\r\n        && currentValue.end.isAfter(item.end)\r\n      ) {\r\n        result.push({ ...item, end: currentValue.start, color: 'blue' })\r\n        result.push({ ...item, start: currentValue.start, color: 'white' })\r\n      }\r\n\r\n      // item            ------------------------\r\n      // currentValue          -----------\r\n      if (currentValue.start.isAfter(item.start) && currentValue.end.isBefore(item.end)\r\n        && currentValue.end.isBefore(item.end)\r\n      ) {\r\n        result.push({ ...item, end: currentValue.start, color: 'blue' })\r\n        result.push({ ...item, start: currentValue.start, end: currentValue.end, color: 'white' })\r\n        result.push({ ...item, start: currentValue.end, color: 'blue' })\r\n        //\r\n        // result.push(currentValue)\r\n      }\r\n\r\n      // item               -----------\r\n      // currentValue  ------------------------\r\n      if (currentValue.start.isBefore(item.start) && currentValue.end.isAfter(item.end)) {\r\n        result.push({ ...item, color: 'white' })\r\n\r\n        // result.push(currentValue)\r\n      }\r\n\r\n\r\n      // item                  ------------\r\n      // currentValue    -----------\r\n      if (currentValue.end.isAfter(item.start) && currentValue.end.isBefore(item.end)\r\n        && currentValue.start.isBefore(item.start)\r\n      ) {\r\n        result.push({ ...item, end: currentValue.end, color: 'white' })\r\n        result.push({ ...item, start: currentValue.end, color: 'blue' })\r\n        // \r\n        // result.push(currentValue)\r\n      }\r\n\r\n      // item         ------------\r\n      // currentValue                -----------\r\n      if (currentValue.start.isSameOrAfter(item.end)) {\r\n        result.push(item)\r\n      }\r\n\r\n      // item                         ------------\r\n      // currentValue  -----------\r\n      if (currentValue.end.isSameOrBefore(item.start)) {\r\n        result.push(item)\r\n      }\r\n\r\n      // 完全重合\r\n      // item           -----------\r\n      // currentValue   -----------\r\n      if (currentValue.start.isSame(item.start) && currentValue.end.isSame(item.end)) {\r\n        result.push({ ...item, color: 'white' })\r\n      }\r\n\r\n\r\n    } else {\r\n      result.push(item)\r\n    }\r\n  })\r\n\r\n  result.push(currentValue)\r\n\r\n  return result\r\n}\r\n\r\n\r\n/**\r\n * 将有重复的时间段分割，并且标记白色或蓝色\r\n * @param {*} scheduleTimes \r\n */\r\nconst splitTime = (scheduleTimes) => {\r\n\r\n  let objectTimes = scheduleTimes.map((times, index) => {\r\n    return times.map(time => {\r\n      return {\r\n        group: index,\r\n        start: time[0],\r\n        end: time[1],\r\n        color: 'blue'\r\n      }\r\n    })\r\n  })\r\n\r\n  const itemTimes = objectTimes.flat()\r\n\r\n  return itemTimes.reduce(splitTimereducer)\r\n}\r\n\r\n/**\r\n * 根据原始schedule数据，计算各个时刻的schedule时间片段\r\n * @param {schdule数据} schedules \r\n * @param {显示的开始日期} show_start_date \r\n * @param {显示的结束日期} show_end_date \r\n */\r\nconst detailTimes = (schedules, show_start_date = '2019-04-01', show_end_date = '2019-04-30') => {\r\n\r\n  return schedules.map((schedule) => {\r\n\r\n    let { available_date_from, available_date_to, available_time_from, available_time_to } = schedule\r\n\r\n    // 期間なしの場合、処理しやすい為、終了日付が大きな値で固定\r\n    available_date_to = available_date_to || '2030-01-01'\r\n\r\n    // 開始時間は大きな方、終了時間は小さい方\r\n    available_date_from = available_date_from < show_start_date ? show_start_date : available_date_from\r\n    available_date_to = available_date_to < show_end_date ? available_date_to : show_end_date\r\n\r\n\r\n    if (!(available_time_from && available_time_to)) {\r\n      // 没有设置时刻\r\n      const startTime = moment(available_date_from)\r\n      const endTime = moment(available_date_to).add(1, 'day')\r\n\r\n      // 连续的时间段\r\n      let times = []\r\n      times.push([startTime, endTime])\r\n\r\n      return times\r\n\r\n    } else { // 时刻有设置\r\n\r\n      // 连续的时间段\r\n      let times = []\r\n\r\n      // 开始日期\r\n      let startDate = moment(available_date_from)\r\n\r\n      // 以 开始日期--结束日期 之间的天数进行循环，计算出每天播放的时间段\r\n      while (startDate.isSameOrBefore(moment(available_date_to))) {\r\n\r\n        console.log(\"moment(available_date_to):\" + moment(available_date_to).format())\r\n\r\n        const day = startDate.format('YYYY-MM-DD')\r\n\r\n        // 当天的播放的开始时刻\r\n        const startTime = moment(`${day} ${available_time_from}`)\r\n        // 当天的播放的结束时刻\r\n        const endTime = moment(`${day} ${available_time_to}`)\r\n\r\n\r\n        times.push([startTime, endTime])\r\n\r\n        // 日付 + 1day，继续下一天的处理\r\n        startDate = startDate.add(1, 'day')\r\n      }\r\n\r\n      return times\r\n    }\r\n  })\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * timeline数据计算与显示\r\n * @param {*} 显示开始日期\r\n * @param {*} 显示结束日期\r\n */\r\nexport default function () {\r\n  let groups = [];\r\n  for (let i = 0; i < schedules.length; i++) {\r\n    groups.push({\r\n      id: `${i}`,\r\n      title: schedules[i].playlist_name,\r\n      rightTitle: schedules[i].schedule_name,\r\n      rightTitleKey: 'rightTitle',\r\n      tip: 'additional information',\r\n      bgColor: '#f00'\r\n    });\r\n  }\r\n\r\n  // 根据原始schedule数据，计算各个时刻的schedule时间片段\r\n  // 没有去重的，播放时间段\r\n  console.log(\"没有去重的，播放时间段\")\r\n  const scheduleTimes = detailTimes(schedules, '2019-04-01', '2019-05-02')\r\n  console.log(scheduleTimes)\r\n\r\n\r\n  // 划分时间片段，标记白蓝色\r\n  console.log(\"标记白蓝时间段\")\r\n  const splitData = splitTime(scheduleTimes)\r\n  console.log(splitData)\r\n\r\n\r\n  // 将连续的白色时间片段合并\r\n  const data = splitData.reduce(connectReducer)\r\n  console.log(data)\r\n\r\n\r\n  // 准备timeline插件显示的数据\r\n  let items = []\r\n  data.forEach((time, i) => {\r\n\r\n    const title = `${time.start.format()}--${time.end.format()}`\r\n\r\n    items.push({\r\n      id: `${i}`,\r\n      group: time.group,\r\n      title: title,\r\n      start: time.start, \r\n      end: time.end,\r\n      itemProps: { \"data-tip\": title },\r\n      bgColor: time.color == \"blue\" ? \"#a8c9ff\" : \"#eee\",\r\n    })\r\n\r\n  })\r\n\r\n  console.log(items)\r\n  // \r\n\r\n  return { groups, items }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport moment from \"moment\";\r\n\r\nimport Timeline from \"react-calendar-timeline\";\r\n\r\nimport generateFakeData from \"./generate-fake-data\";\r\n\r\nvar keys = {\r\n  groupIdKey: \"id\",\r\n  groupTitleKey: \"title\",\r\n  groupRightTitleKey: \"rightTitle\",\r\n  itemIdKey: \"id\",\r\n  itemTitleKey: \"title\",\r\n  itemDivTitleKey: \"title\",\r\n  itemGroupKey: \"group\",\r\n  itemTimeStartKey: \"start\",\r\n  itemTimeEndKey: \"end\",\r\n  groupLabelKey: \"title\"\r\n};\r\n\r\nconst dateFormat = 'YYYY-MM-DDTHH:mm:ss'\r\n\r\n\r\nexport default class App extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    const { groups, items } = generateFakeData();\r\n    const defaultTimeStart = moment()\r\n      .startOf(\"day\")\r\n      .add(10, \"day\")\r\n      .toDate();\r\n    const defaultTimeEnd = moment()\r\n      .startOf(\"day\")\r\n      .add(40, \"day\")\r\n      .toDate();\r\n\r\n    this.state = {\r\n      groups,\r\n      items,\r\n      defaultTimeStart,\r\n      defaultTimeEnd\r\n    };\r\n\r\n    console.log(\"defaultTimeStart: \" + defaultTimeStart  )\r\n    console.log(\"defaultTimeEnd: \" + defaultTimeEnd )\r\n  }\r\n\r\n  itemRenderer = ({\r\n    item,\r\n    timelineContext,\r\n    itemContext,\r\n    getItemProps,\r\n    getResizeProps\r\n  }) => {\r\n    const { left: leftResizeProps, right: rightResizeProps } = getResizeProps();\r\n    const backgroundColor = itemContext.selected\r\n      ? itemContext.dragging\r\n        ? \"red\"\r\n        : item.selectedBgColor\r\n      : item.bgColor;\r\n    const borderColor = itemContext.resizing ? \"red\" : item.color;\r\n    return (\r\n      <div\r\n        {...getItemProps({\r\n          style: {\r\n            backgroundColor,\r\n            color: item.color,\r\n            borderColor,\r\n            borderStyle: \"solid\",\r\n            borderWidth: 1,\r\n            borderRadius: 4,\r\n            borderLeftWidth: itemContext.selected ? 3 : 1,\r\n            borderRightWidth: itemContext.selected ? 3 : 1\r\n          },\r\n          onMouseDown: () => {\r\n            console.log(\"on item click\", item);\r\n            console.log(\"start date: \", moment(item.start).format(dateFormat));\r\n            console.log(\"end date  : \", moment(item.end).format(dateFormat));\r\n          },\r\n        })}\r\n      >\r\n        {itemContext.useResizeHandle ? <div {...leftResizeProps} /> : null}\r\n\r\n        <div\r\n          style={{\r\n            height: itemContext.dimensions.height,\r\n            overflow: \"hidden\",\r\n            paddingLeft: 3,\r\n            textOverflow: \"ellipsis\",\r\n            whiteSpace: \"nowrap\"\r\n          }}\r\n        >\r\n          {itemContext.title}\r\n        </div>\r\n\r\n        {itemContext.useResizeHandle ? <div {...rightResizeProps} /> : null}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  handleItemMove = (itemId, dragTime, newGroupOrder) => {\r\n    const { items, groups } = this.state;\r\n\r\n    const group = groups[newGroupOrder];\r\n\r\n    this.setState({\r\n      items: items.map(item =>\r\n        item.id === itemId\r\n          ? Object.assign({}, item, {\r\n              start: dragTime,\r\n              end: dragTime + (item.end - item.start),\r\n              group: group.id\r\n            })\r\n          : item\r\n      )\r\n    });\r\n\r\n    console.log(\"Moved\", itemId, dragTime, newGroupOrder);\r\n  };\r\n\r\n  handleItemResize = (itemId, time, edge) => {\r\n    const { items } = this.state;\r\n\r\n    this.setState({\r\n      items: items.map(item =>\r\n        item.id === itemId\r\n          ? Object.assign({}, item, {\r\n              start: edge === \"left\" ? time : item.start,\r\n              end: edge === \"left\" ? item.end : time\r\n            })\r\n          : item\r\n      )\r\n    });\r\n\r\n    console.log(\"Resized\", itemId, time, edge);\r\n  };\r\n\r\n  onBoundsChange = (canvasTimeStart, canvasTimeEnd) => {\r\n    console.log(\"onBoundsChange----->\");\r\n\r\n    console.log(\"canvasTimeStart:\" + moment(canvasTimeStart).format());\r\n    console.log(\"canvasTimeEnd:\" + moment(canvasTimeEnd).format());\r\n\r\n  };\r\n\r\n  onTimeChange = (visibleTimeStart, visibleTimeEnd, updateScrollCanvas) => {\r\n    console.log(\"onTimeChange----->\");\r\n\r\n    console.log(\"visibleTimeStart:\" + moment(visibleTimeStart).format());\r\n    console.log(\"visibleTimeEnd:\" + moment(visibleTimeEnd).format());\r\n    // console.log(\"updateScrollCanvas:\" + updateScrollCanvas);\r\n  }\r\n\r\n\r\n  render() {\r\n    const { groups, items, defaultTimeStart, defaultTimeEnd } = this.state;\r\n\r\n    return (\r\n      <Timeline\r\n        groups={groups}\r\n        items={items}\r\n        keys={keys}\r\n        sidebarContent={<div>Above The Left</div>}\r\n        itemsSorted\r\n        itemTouchSendsClick={false}\r\n        stackItems\r\n        itemHeightRatio={0.75}\r\n        showCursorLine\r\n        canMove={false}\r\n        canResize={false}\r\n        defaultTimeStart={defaultTimeStart}\r\n        defaultTimeEnd={defaultTimeEnd}\r\n        itemRenderer={this.itemRenderer}\r\n        onItemMove={this.handleItemMove}\r\n        onItemResize={this.handleItemResize}\r\n        onBoundsChange={this.onBoundsChange}\r\n        // onTimeChange={this.onTimeChange}\r\n      />\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport { render } from \"react-dom\";\r\nimport CustomTimeline from \"./CustomTimeline\";\r\nimport 'react-calendar-timeline/lib/Timeline.css'\r\n\r\nconst App = () => (\r\n  <div>\r\n    <CustomTimeline />\r\n  </div>\r\n);\r\n\r\nrender(<App />, document.getElementById(\"root\"));\r\n\r\nexport default App;","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read http://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: http://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}