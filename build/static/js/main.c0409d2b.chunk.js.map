{"version":3,"sources":["generate-fake-data.js","CustomTimeline.jsx","App.js","serviceWorker.js","index.js"],"names":["schedules","schedule_name","playlist_name","available_date_from","available_date_to","available_time_from","available_time_to","timeline","value","generate_fake_data","showStartDate","arguments","length","undefined","showEndDate","groups","i","push","id","concat","title","rightTitle","rightTitleKey","tip","bgColor","scheduleTimes","forEach","schedule","index","console","log","times","startDate","moment","isSameOrBefore","format","day","startTime","endTime","add","splitData","splitTime","data","reduce","accumulator","currentValue","target","Array","isArray","lastItem","pop","group","JSON","stringify","color","end","isSame","start","newItem","Object","objectSpread","items","time","itemProps","data-tip","faker","hacker","phrase","objectTimes","map","flat","result","item","isAfter","isBefore","keys","groupIdKey","groupTitleKey","groupRightTitleKey","itemIdKey","itemTitleKey","itemDivTitleKey","itemGroupKey","itemTimeStartKey","itemTimeEndKey","groupLabelKey","dateFormat","App","props","_this","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","itemRenderer","_ref","itemContext","timelineContext","getItemProps","_getResizeProps","getResizeProps","leftResizeProps","left","rightResizeProps","right","backgroundColor","selected","dragging","selectedBgColor","borderColor","resizing","react_default","a","createElement","style","borderStyle","borderWidth","borderRadius","borderLeftWidth","borderRightWidth","onMouseDown","useResizeHandle","height","dimensions","overflow","paddingLeft","textOverflow","whiteSpace","handleItemMove","itemId","dragTime","newGroupOrder","_this$state","state","setState","assign","handleItemResize","edge","onBoundsChange","canvasTimeStart","canvasTimeEnd","onTimeChange","visibleTimeStart","visibleTimeEnd","updateScrollCanvas","_generateFakeData","generateFakeData","defaultTimeStart","startOf","toDate","defaultTimeEnd","_this$state2","lib_default","sidebarContent","itemsSorted","itemTouchSendsClick","stackItems","itemHeightRatio","showCursorLine","canMove","canResize","onItemMove","onItemResize","Component","CustomTimeline_App","render","App_App","document","getElementById","Boolean","window","location","hostname","match","ReactDOM","src_App","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c0409d2b.chunk.js","sourcesContent":["import faker from \"faker\";\r\nimport randomColor from \"randomcolor\";\r\nimport moment from \"moment\";\r\nimport { SSL_OP_CRYPTOPRO_TLSEXT_BUG } from \"constants\";\r\n\r\nconst dateFormat = 'YYYY-MM-DDTHH:mm:ss'\r\n\r\n\r\nconst schedules = [\r\n  {\r\n    schedule_name: 'schedule_name_001',\r\n    playlist_name: 'playlist_name_001',\r\n    available_date_from: '2019-03-01',\r\n    available_date_to: '2019-03-03',\r\n    available_time_from: '08:00:00',\r\n    available_time_to: '20:00:00',\r\n  },\r\n  {\r\n    schedule_name: 'schedule_name_002',\r\n    playlist_name: 'playlist_name_002',\r\n    available_date_from: '2019-03-02',\r\n    available_date_to: '2019-03-19',\r\n    available_time_from: '',\r\n    available_time_to: '',\r\n  },\r\n  {\r\n    schedule_name: 'schedule_name_003',\r\n    playlist_name: 'playlist_name_003',\r\n    available_date_from: '2019-02-28',\r\n    available_date_to: '2019-03-07',\r\n    available_time_from: '19:00:00',\r\n    available_time_to: '22:00:00',\r\n  },\r\n  {\r\n    schedule_name: 'schedule_name_004',\r\n    playlist_name: 'playlist_name_004',\r\n    available_date_from: '2019-03-06',\r\n    available_date_to: '2019-03-10',\r\n    available_time_from: '',\r\n    available_time_to: '',\r\n  },\r\n  {\r\n    schedule_name: 'schedule_name_005',\r\n    playlist_name: 'playlist_name_005',\r\n    available_date_from: '2019-03-06',\r\n    available_date_to: '',\r\n    available_time_from: '14:00:00',\r\n    available_time_to: '16:00:00',\r\n  },\r\n]\r\n\r\n\r\nconst timeline = (value) =>{ return value} // { return Math.floor(value.valueOf() / 10000000) * 10000000;  }\r\n\r\n\r\nexport default function(showStartDate='2019-03-02', showEndDate='2019-03-10') {\r\n  let groups = [];\r\n  for (let i = 0; i < schedules.length; i++) {\r\n    groups.push({\r\n      id: `${i}`,\r\n      title: schedules[i].playlist_name,\r\n      rightTitle: schedules[i].schedule_name,\r\n      rightTitleKey: 'rightTitle',\r\n      tip: 'additional information',\r\n      bgColor: '#f00'\r\n    });\r\n  }\r\n\r\n  let scheduleTimes = []\r\n\r\n  schedules.forEach( (schedule, index) => {\r\n    let { available_date_from, available_date_to, available_time_from, available_time_to } = schedule\r\n\r\n    // 期間なしの場合、処理しやすい為、終了日付が大きな値で固定\r\n    available_date_to = available_date_to || '2030-01-01'\r\n\r\n    // 開始時間は大きな方、終了時間は小さい方\r\n    available_date_from = available_date_from < showStartDate ? showStartDate : available_date_from\r\n    available_date_to  = available_date_to < showEndDate ? available_date_to : showEndDate\r\n\r\n    console.log(\"  \")\r\n    console.log(\"--> index: \" + index + \" available_date_from: \" + available_date_from + \" available_date_to: \" + available_date_to + \" available_time_from: \" + available_time_from + \" available_time_to: \" + available_time_to)\r\n\r\n    if( ! (available_time_from && available_time_to) ) {\r\n      // 時刻設定なし\r\n\r\n      const startTime = moment(available_date_from)\r\n      const endTime = moment(available_date_to).add(1, 'day')\r\n      \r\n      let times = []\r\n      times.push([timeline(startTime), timeline(endTime)])\r\n      scheduleTimes.push(times)\r\n\r\n    } else {\r\n      // 時刻設定あり\r\n      let times = []\r\n      let startDate = moment(available_date_from)\r\n\r\n      while( startDate.isSameOrBefore(moment(available_date_to)) ) {\r\n\r\n        console.log(\"moment(available_date_to):\"  + moment(available_date_to).format())\r\n\r\n        const day = startDate.format('YYYY-MM-DD')\r\n        const startTime = moment(`${day} ${available_time_from}`)\r\n        const endTime = moment(`${day} ${available_time_to}`)\r\n\r\n        times.push([timeline(startTime), timeline(endTime)])\r\n\r\n        // 日付 + 1day\r\n        startDate = startDate.add(1, 'day')\r\n      }\r\n\r\n      scheduleTimes.push(times)\r\n    }\r\n\r\n  })\r\n\r\n  console.log(scheduleTimes)\r\n  \r\n\r\n  const splitData = splitTime(scheduleTimes)\r\n\r\n\r\n  // 連続の白い部分を接続する\r\n  console.log(\"-----------------------連続の白い部分を接続する \")\r\n\r\n  const connectReducer = (accumulator, currentValue) => {\r\n    let target = []\r\n    if (!Array.isArray(accumulator)) {\r\n      target.push(accumulator)\r\n    } else {\r\n      target = accumulator\r\n    }\r\n\r\n    let lastItem = target.pop()\r\n    console.log(\"\")\r\n    console.log(\"--------------------\" + lastItem.group + \"   \" + currentValue.group)\r\n    console.log(\"lastItem    : \" + JSON.stringify(lastItem))\r\n    console.log(\"currentValue: \" + JSON.stringify(currentValue))\r\n\r\n\r\n    if(lastItem.group == currentValue.group \r\n      && lastItem.color == currentValue.color && lastItem.color == \"white\" \r\n      && lastItem.end.isSame(currentValue.start)) \r\n    {\r\n      const newItem = {...lastItem, start: lastItem.start, end: currentValue.end}\r\n      target.push(newItem)\r\n      console.log(\"---connect: \" + JSON.stringify(newItem))\r\n    } else {\r\n      target.push(lastItem)\r\n      target.push(currentValue)\r\n    }\r\n\r\n    return target\r\n  }\r\n\r\n  const data = splitData.reduce(connectReducer)\r\n  console.log(data)\r\n\r\n\r\n\r\n  // {id: \"0\", group: \"2\", title: \"time_0\", start: 1550770000000, end: 1550790921150, …}\r\n  let items = []\r\n\r\n  data.forEach( (time, i ) => {\r\n\r\n    items.push({\r\n        id: `${i}`, \r\n        group: time.group, \r\n        title: `${time.start.format()}--${time.end.format()}`, \r\n        start: time.start, // Math.floor(time.start.valueOf() / 10000000) * 10000000, \r\n        end:   time.end,  // Math.floor(time.end.valueOf() / 10000000) * 10000000,\r\n        itemProps: {\r\n          \"data-tip\": faker.hacker.phrase()\r\n        },\r\n        bgColor:  time.color == \"blue\" ? \"#a8c9ff\" : \"#eee\",\r\n      })\r\n      \r\n  })\r\n\r\n  console.log(items)\r\n  // \r\n\r\n  \r\n\r\n  return {groups, items}\r\n}\r\n\r\n\r\nconst splitTime = (scheduleTimes) => {\r\n\r\n  let objectTimes = scheduleTimes.map( (times, index) => {\r\n\r\n    return times.map(time => {\r\n      return {\r\n        group: index,\r\n        start: time[0],\r\n        end: time[1],\r\n        // formatedStart: time[0].format(),\r\n        // formatedEnd: time[1].format(),\r\n        color: 'blue'\r\n      }\r\n    })\r\n\r\n  })\r\n\r\n\r\n  console.log(\"objectTimes\")\r\n  console.log(objectTimes)\r\n\r\n  const itemTimes = objectTimes.flat()\r\n\r\n\r\n  const reducer = (accumulator, currentValue) => {\r\n\r\n    let target = []\r\n    if (!Array.isArray(accumulator)) {\r\n      target.push(accumulator)\r\n    } else {\r\n      target = accumulator\r\n    }\r\n    \r\n    console.log(\"\")\r\n    console.log(\"-------> target: \")\r\n    console.log(target)\r\n    console.log(\"-------> currentValue: \")\r\n    console.log(JSON.stringify(currentValue))\r\n\r\n\r\n    let result = []\r\n\r\n    target.forEach( item => {\r\n      // currentValue.start\r\n      // currentValue.end\r\n\r\n      if(item.color == 'blue' && item.group != currentValue.group)  {\r\n\r\n          // item          --------\r\n          // currentValue       -----------\r\n          if (currentValue.start.isAfter(item.start) && currentValue.start.isBefore(item.end)\r\n            && currentValue.end.isAfter(item.end)\r\n          ) {\r\n            result.push({...item, end: currentValue.start, color: 'blue'})\r\n            result.push({...item, start: currentValue.start, color: 'white'})\r\n            // \r\n            // result.push(currentValue)\r\n          }\r\n\r\n          // item            ------------------------\r\n          // currentValue          -----------\r\n          if (currentValue.start.isAfter(item.start) && currentValue.end.isBefore(item.end) \r\n            && currentValue.end.isBefore(item.end)\r\n          ) {\r\n            result.push({...item, end: currentValue.start, color: 'blue'})\r\n            result.push({...item, start: currentValue.start, end: currentValue.end, color: 'white'})\r\n            result.push({...item, start: currentValue.end, color: 'blue'})\r\n            //\r\n            // result.push(currentValue)\r\n          }\r\n\r\n          // item               -----------\r\n          // currentValue  ------------------------\r\n          if (currentValue.start.isBefore(item.start) && currentValue.end.isAfter(item.end)) {\r\n            result.push({...item, color: 'white'})\r\n\r\n            // result.push(currentValue)\r\n          }\r\n\r\n\r\n          // item                  ------------\r\n          // currentValue    -----------\r\n          if (currentValue.end.isAfter(item.start) && currentValue.end.isBefore(item.end)\r\n            && currentValue.start.isBefore(item.start)\r\n          ) {\r\n            result.push({...item, end: currentValue.end, color: 'white'})\r\n            result.push({...item, start: currentValue.end, color: 'blue'})\r\n            // \r\n            // result.push(currentValue)\r\n          }\r\n\r\n          // item         ------------\r\n          // currentValue                -----------\r\n          if (currentValue.start.isAfter(item.end)) {\r\n            result.push(item)\r\n\r\n            // result.push(currentValue)\r\n          }\r\n\r\n          // item                         ------------\r\n          // currentValue  -----------\r\n          if (currentValue.end.isBefore(item.start)) {\r\n            result.push(item)\r\n\r\n            // result.push(currentValue)\r\n          }\r\n\r\n      } else {\r\n        result.push(item)\r\n      }\r\n      \r\n\r\n      \r\n\r\n    })\r\n\r\n    result.push(currentValue)\r\n\r\n    return result\r\n  }\r\n\r\n\r\n  const splitData = itemTimes.reduce(reducer)\r\n  \r\n  console.log(\"\")\r\n  console.log(\"---> reduce result: \")\r\n  console.log(splitData)\r\n  \r\n  return splitData\r\n}\r\n","import React, { Component } from \"react\";\r\nimport moment from \"moment\";\r\n\r\nimport Timeline from \"react-calendar-timeline\";\r\n\r\nimport generateFakeData from \"./generate-fake-data\";\r\n\r\nvar keys = {\r\n  groupIdKey: \"id\",\r\n  groupTitleKey: \"title\",\r\n  groupRightTitleKey: \"rightTitle\",\r\n  itemIdKey: \"id\",\r\n  itemTitleKey: \"title\",\r\n  itemDivTitleKey: \"title\",\r\n  itemGroupKey: \"group\",\r\n  itemTimeStartKey: \"start\",\r\n  itemTimeEndKey: \"end\",\r\n  groupLabelKey: \"title\"\r\n};\r\n\r\nconst dateFormat = 'YYYY-MM-DDTHH:mm:ss'\r\n\r\n\r\nexport default class App extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    const { groups, items } = generateFakeData();\r\n    const defaultTimeStart = moment()\r\n      .startOf(\"day\")\r\n      .add(10, \"day\")\r\n      .toDate();\r\n    const defaultTimeEnd = moment()\r\n      .startOf(\"day\")\r\n      .add(40, \"day\")\r\n      .toDate();\r\n\r\n    this.state = {\r\n      groups,\r\n      items,\r\n      defaultTimeStart,\r\n      defaultTimeEnd\r\n    };\r\n\r\n    console.log(\"defaultTimeStart: \" + defaultTimeStart  )\r\n    console.log(\"defaultTimeEnd: \" + defaultTimeEnd )\r\n  }\r\n\r\n  itemRenderer = ({\r\n    item,\r\n    timelineContext,\r\n    itemContext,\r\n    getItemProps,\r\n    getResizeProps\r\n  }) => {\r\n    const { left: leftResizeProps, right: rightResizeProps } = getResizeProps();\r\n    const backgroundColor = itemContext.selected\r\n      ? itemContext.dragging\r\n        ? \"red\"\r\n        : item.selectedBgColor\r\n      : item.bgColor;\r\n    const borderColor = itemContext.resizing ? \"red\" : item.color;\r\n    return (\r\n      <div\r\n        {...getItemProps({\r\n          style: {\r\n            backgroundColor,\r\n            color: item.color,\r\n            borderColor,\r\n            borderStyle: \"solid\",\r\n            borderWidth: 1,\r\n            borderRadius: 4,\r\n            borderLeftWidth: itemContext.selected ? 3 : 1,\r\n            borderRightWidth: itemContext.selected ? 3 : 1\r\n          },\r\n          onMouseDown: () => {\r\n            console.log(\"on item click\", item);\r\n            console.log(\"start date: \", moment(item.start).format(dateFormat));\r\n            console.log(\"end date  : \", moment(item.end).format(dateFormat));\r\n          },\r\n        })}\r\n      >\r\n        {itemContext.useResizeHandle ? <div {...leftResizeProps} /> : null}\r\n\r\n        <div\r\n          style={{\r\n            height: itemContext.dimensions.height,\r\n            overflow: \"hidden\",\r\n            paddingLeft: 3,\r\n            textOverflow: \"ellipsis\",\r\n            whiteSpace: \"nowrap\"\r\n          }}\r\n        >\r\n          {itemContext.title}\r\n        </div>\r\n\r\n        {itemContext.useResizeHandle ? <div {...rightResizeProps} /> : null}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  handleItemMove = (itemId, dragTime, newGroupOrder) => {\r\n    const { items, groups } = this.state;\r\n\r\n    const group = groups[newGroupOrder];\r\n\r\n    this.setState({\r\n      items: items.map(item =>\r\n        item.id === itemId\r\n          ? Object.assign({}, item, {\r\n              start: dragTime,\r\n              end: dragTime + (item.end - item.start),\r\n              group: group.id\r\n            })\r\n          : item\r\n      )\r\n    });\r\n\r\n    console.log(\"Moved\", itemId, dragTime, newGroupOrder);\r\n  };\r\n\r\n  handleItemResize = (itemId, time, edge) => {\r\n    const { items } = this.state;\r\n\r\n    this.setState({\r\n      items: items.map(item =>\r\n        item.id === itemId\r\n          ? Object.assign({}, item, {\r\n              start: edge === \"left\" ? time : item.start,\r\n              end: edge === \"left\" ? item.end : time\r\n            })\r\n          : item\r\n      )\r\n    });\r\n\r\n    console.log(\"Resized\", itemId, time, edge);\r\n  };\r\n\r\n  onBoundsChange = (canvasTimeStart, canvasTimeEnd) => {\r\n    console.log(\"onBoundsChange----->\");\r\n\r\n    console.log(\"canvasTimeStart:\" + moment(canvasTimeStart).format());\r\n    console.log(\"canvasTimeEnd:\" + moment(canvasTimeEnd).format());\r\n\r\n  };\r\n\r\n  onTimeChange = (visibleTimeStart, visibleTimeEnd, updateScrollCanvas) => {\r\n    console.log(\"onTimeChange----->\");\r\n\r\n    console.log(\"visibleTimeStart:\" + moment(visibleTimeStart).format());\r\n    console.log(\"visibleTimeEnd:\" + moment(visibleTimeEnd).format());\r\n    // console.log(\"updateScrollCanvas:\" + updateScrollCanvas);\r\n  }\r\n\r\n\r\n  render() {\r\n    const { groups, items, defaultTimeStart, defaultTimeEnd } = this.state;\r\n\r\n    return (\r\n      <Timeline\r\n        groups={groups}\r\n        items={items}\r\n        keys={keys}\r\n        sidebarContent={<div>Above The Left</div>}\r\n        itemsSorted\r\n        itemTouchSendsClick={false}\r\n        stackItems\r\n        itemHeightRatio={0.75}\r\n        showCursorLine\r\n        canMove={false}\r\n        canResize={false}\r\n        defaultTimeStart={defaultTimeStart}\r\n        defaultTimeEnd={defaultTimeEnd}\r\n        itemRenderer={this.itemRenderer}\r\n        onItemMove={this.handleItemMove}\r\n        onItemResize={this.handleItemResize}\r\n        onBoundsChange={this.onBoundsChange}\r\n        // onTimeChange={this.onTimeChange}\r\n      />\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport { render } from \"react-dom\";\r\nimport CustomTimeline from \"./CustomTimeline\";\r\nimport 'react-calendar-timeline/lib/Timeline.css'\r\n\r\nconst App = () => (\r\n  <div>\r\n    <CustomTimeline />\r\n  </div>\r\n);\r\n\r\nrender(<App />, document.getElementById(\"root\"));\r\n\r\nexport default App;","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read http://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: http://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}